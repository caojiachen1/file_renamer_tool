name: Build and Release

on:
  push:
    tags:
      - 'v*.*.*'  # Trigger condition: push tags like v1.0.0
    branches:
      - main
      - master  # Support auto-release via commit message
  workflow_dispatch:  # Allow manual trigger
    inputs:
      version_type:
        description: 'Version update type'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major
      custom_version:
        description: 'Custom version number (e.g., v2.0.1, leave empty for auto-increment)'
        required: false
        default: ''

jobs:
  build-and-release:
    runs-on: windows-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup MSBuild
      uses: microsoft/setup-msbuild@v2
      
    - name: Setup CMake
      uses: lukka/get-cmake@latest
      
    - name: Get version from tag or input
      id: version
      shell: pwsh
      run: |
        if ("${{ github.event_name }}" -eq "workflow_dispatch") {
          # Manual trigger case
          $custom_version = "${{ github.event.inputs.custom_version }}"
          
          if ($custom_version -and $custom_version.Trim() -ne "") {
            # Use custom version number
            $version = $custom_version.Trim()
            Write-Host "Using custom version: $version"
          } else {
            # Auto-increment version number
            $version_type = "${{ github.event.inputs.version_type }}"
            Write-Host "Version update type: $version_type"
            
            # Use GitHub API to get the latest release
            try {
              $headers = @{
                'Authorization' = 'token ${{ secrets.GITHUB_TOKEN }}'
                'Accept' = 'application/vnd.github.v3+json'
              }
              
              $response = Invoke-RestMethod -Uri "https://api.github.com/repos/${{ github.repository }}/releases/latest" -Headers $headers -ErrorAction SilentlyContinue
              
              if ($response -and $response.tag_name) {
                $latest_tag = $response.tag_name
                Write-Host "Found latest release tag via API: $latest_tag"
              } else {
                # If no release, try to get the latest tag
                $tags_response = Invoke-RestMethod -Uri "https://api.github.com/repos/${{ github.repository }}/tags" -Headers $headers -ErrorAction SilentlyContinue
                if ($tags_response -and $tags_response.Length -gt 0) {
                  $latest_tag = $tags_response[0].name
                  Write-Host "Found latest tag via API: $latest_tag"
                } else {
                  $latest_tag = "v2.0.0"
                  Write-Host "No tags found, using default version: $latest_tag"
                }
              }
            } catch {
              # Fallback to git command
              Write-Host "API call failed, falling back to git command"
              $latest_tag = git describe --tags --abbrev=0 2>$null
              if (-not $latest_tag) {
                $latest_tag = "v2.0.0"
                Write-Host "No existing tags found, using default version: $latest_tag"
              } else {
                Write-Host "Found latest tag via git: $latest_tag"
              }
            }
            
            # Parse version number
            if ($latest_tag -match '^v(\d+)\.(\d+)\.(\d+)$') {
              $major = [int]$matches[1]
              $minor = [int]$matches[2]
              $patch = [int]$matches[3]
              
              # Increment version number based on type
              switch ($version_type) {
                "major" { 
                  $major++
                  $minor = 0
                  $patch = 0
                }
                "minor" { 
                  $minor++
                  $patch = 0
                }
                "patch" { 
                  $patch++
                }
              }
              
              $version = "v$major.$minor.$patch"
              Write-Host "Auto-incremented version: $version"
            } else {
              Write-Error "Unable to parse version format: $latest_tag"
              exit 1
            }
          }
        } else {
          # Push-triggered case (tag push or branch push)
          if ("${{ github.ref_type }}" -eq "tag") {
            # Tag push trigger
            $version = "${{ github.ref_name }}"
            Write-Host "Version from tag: $version"
          } else {
            # Branch push trigger - check commit message for auto-release
            $commit_message = git log -1 --pretty=format:"%s%n%b"
            Write-Host "Checking commit message: $commit_message"
            
            # Check for version control keywords in commit message
            $auto_version_type = $null
            
            # Check [] markers at the end first
            if ($commit_message -match '\[major\]$') {
              $auto_version_type = "major"
            } elseif ($commit_message -match '\[minor\]$') {
              $auto_version_type = "minor"
            } elseif ($commit_message -match '\[patch\]$') {
              $auto_version_type = "patch"
            }
            # If no [] markers, check other keywords
            elseif ($commit_message -match '\bmajor:|\bbreaking\s*change|\bBREAKING\s*CHANGE') {
              $auto_version_type = "major"
            } elseif ($commit_message -match '\bminor:|\bfeat:|\bfeature:') {
              $auto_version_type = "minor"
            } elseif ($commit_message -match '\bpatch:|\bfix:|\bbugfix:') {
              $auto_version_type = "patch"
            }
            
            if (-not $auto_version_type) {
              Write-Host "No version control keywords found in commit message, skipping auto-release"
              Write-Host "Supported marker formats:"
              Write-Host "  - At end of message: [major], [minor], [patch]"
              Write-Host "  - Prefix keywords: major:, minor:, patch:, feat:, fix:, etc."
              Write-Host "Current commit: $commit_message"
              exit 0
            }
            
            Write-Host "Detected version type from commit message: $auto_version_type"
            
            # Use GitHub API to get latest release for auto-version calculation
            try {
              $headers = @{
                'Authorization' = 'token ${{ secrets.GITHUB_TOKEN }}'
                'Accept' = 'application/vnd.github.v3+json'
              }
              
              $response = Invoke-RestMethod -Uri "https://api.github.com/repos/${{ github.repository }}/releases/latest" -Headers $headers -ErrorAction SilentlyContinue
              
              if ($response -and $response.tag_name) {
                $latest_tag = $response.tag_name
                Write-Host "Found latest release tag via API: $latest_tag"
              } else {
                # If no release, try to get the latest tag
                $tags_response = Invoke-RestMethod -Uri "https://api.github.com/repos/${{ github.repository }}/tags" -Headers $headers -ErrorAction SilentlyContinue
                if ($tags_response -and $tags_response.Length -gt 0) {
                  $latest_tag = $tags_response[0].name
                  Write-Host "Found latest tag via API: $latest_tag"
                } else {
                  $latest_tag = "v2.0.0"
                  Write-Host "No tags found, using default version: $latest_tag"
                }
              }
              
              # Parse and increment version number
              if ($latest_tag -match '^v(\d+)\.(\d+)\.(\d+)$') {
                $major = [int]$matches[1]
                $minor = [int]$matches[2]
                $patch = [int]$matches[3]
                
                switch ($auto_version_type) {
                  "major" { 
                    $major++
                    $minor = 0
                    $patch = 0
                  }
                  "minor" { 
                    $minor++
                    $patch = 0
                  }
                  "patch" { 
                    $patch++
                  }
                }
                
                $version = "v$major.$minor.$patch"
                Write-Host "Auto-incremented version based on commit: $latest_tag â†’ $version"
              } else {
                Write-Error "Unable to parse version format: $latest_tag"
                exit 1
              }
            } catch {
              Write-Error "API call failed, unable to auto-generate version"
              exit 1
            }
          }
        }
        
        # Ensure version format is correct (vMajor.Minor.Patch)
        if ($version -notmatch '^v\d+\.\d+\.\d+$') {
          Write-Error "Version format error. Please use vMajor.Minor.Patch format (e.g., v2.0.1)"
          Write-Error "Current version: $version"
          exit 1
        }
        
        Write-Output "version=$version" >> $env:GITHUB_OUTPUT
        Write-Output "version_number=$($version.Substring(1))" >> $env:GITHUB_OUTPUT
        Write-Host "Final version: $version"
        
    - name: Update version in CMakeLists.txt
      shell: pwsh
      run: |
        $version_number = "${{ steps.version.outputs.version_number }}"
        $cmake_content = Get-Content CMakeLists.txt -Raw
        $cmake_content = $cmake_content -replace 'project\(FileRenamerTool VERSION \d+\.\d+\.\d+', "project(FileRenamerTool VERSION $version_number"
        Set-Content CMakeLists.txt $cmake_content
        Write-Host "Updated version in CMakeLists.txt to: $version_number"
        
    - name: Create and push tag (for manual trigger and auto release)
      if: github.event_name == 'workflow_dispatch' || (github.event_name == 'push' && github.ref_type == 'branch')
      shell: pwsh
      run: |
        $version = "${{ steps.version.outputs.version }}"
        
        Write-Host "Processing tag: $version"
        
        # Configure git user info
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        
        # Check if remote tag exists
        $remote_tag = git ls-remote --tags origin $version 2>$null
        if ($remote_tag) {
          Write-Host "âœ“ Remote tag $version already exists, reusing"
          
          # Check if local tag exists, fetch from remote if not
          $local_tag = git tag -l $version
          if (-not $local_tag) {
            Write-Host "Local tag does not exist, fetching from remote..."
            git fetch origin "refs/tags/$version`:refs/tags/$version" 2>$null
            Write-Host "âœ“ Fetched tag $version from remote"
          } else {
            Write-Host "âœ“ Local tag $version also exists"
          }
        } else {
          Write-Host "Remote tag $version does not exist, preparing to create..."
          
          # Check if local tag exists
          $local_tag = git tag -l $version
          if ($local_tag) {
            Write-Host "Local tag $version already exists, pushing to remote..."
            try {
              git push origin $version
              Write-Host "âœ“ Tag $version pushed to remote"
            } catch {
              Write-Host "âš  Error pushing tag, may already exist remotely"
              # Re-check remote tag
              $remote_check = git ls-remote --tags origin $version 2>$null
              if ($remote_check) {
                Write-Host "âœ“ Confirmed remote tag now exists, continuing"
              } else {
                Write-Error "Push failed and remote tag still does not exist"
                exit 1
              }
            }
          } else {
            Write-Host "Creating new tag: $version"
            git tag $version
            if ($LASTEXITCODE -eq 0) {
              Write-Host "âœ“ Local tag $version created successfully"
              
              try {
                git push origin $version
                Write-Host "âœ“ Tag $version pushed to remote"
              } catch {
                Write-Host "âš  Error pushing tag, possibly due to concurrent creation"
                # Re-check remote tag
                $remote_check = git ls-remote --tags origin $version 2>$null
                if ($remote_check) {
                  Write-Host "âœ“ Confirmed remote tag now exists, continuing"
                } else {
                  Write-Error "Push failed and remote tag still does not exist"
                  exit 1
                }
              }
            } else {
              Write-Error "Failed to create local tag"
              exit 1
            }
          }
        }
        
        Write-Host "âœ… Tag processing completed: $version"
        
    - name: Build project
      shell: cmd
      run: |
        echo Starting project build...
        setlocal enabledelayedexpansion
        
        echo ðŸ”§ Building CPU version ^(standard mode^)...
        echo Configuring CMake ^(CPU mode^)...
        cmake -B build -S . -DCMAKE_BUILD_TYPE=Release -DUSE_CUDA=OFF
        set CMAKE_EXIT_CODE=!errorlevel!
        
        if !CMAKE_EXIT_CODE! neq 0 (
          echo âŒ CMake configuration failed!
          exit /b !CMAKE_EXIT_CODE!
        ) else (
          echo âœ“ CPU version CMake configuration successful
        )
        
        echo Building project...
        cmake --build build --config Release --verbose
        set BUILD_EXIT_CODE=!errorlevel!
        if !BUILD_EXIT_CODE! neq 0 (
          echo âŒ Build failed!
          exit /b !BUILD_EXIT_CODE!
        )
        
        echo Copying executable to root directory...
        if exist "build\Release\file_renamer_cli.exe" (
          copy "build\Release\file_renamer_cli.exe" "file_renamer.exe" >nul 2>&1
          echo âœ… CPU version build completed!
        ) else (
          echo âŒ Build artifacts not found!
          echo Searching for possible build artifact locations...
          dir /s build\*.exe 2>nul
          exit /b 1
        )
        
    - name: Verify build artifacts
      shell: pwsh
      run: |
        Write-Host "Verifying build artifacts..."
        
        $release_exe = "build\Release\file_renamer_cli.exe"
        $root_exe = "file_renamer.exe"
        $debug_exe = "build\Debug\file_renamer_cli.exe"
        
        if (Test-Path $release_exe) {
          Write-Host "âœ“ Found Release version: $release_exe"
          $size = (Get-Item $release_exe).Length
          Write-Host "  File size: $([math]::Round($size/1KB, 2)) KB"
        } else {
          Write-Error "âœ— Release version not found: $release_exe"
          exit 1
        }
        
        if (Test-Path $debug_exe) {
          Write-Host "âœ“ Found Debug version: $debug_exe"
        } else {
          Write-Host "âš  Debug version not found: $debug_exe"
        }
        
        if (Test-Path $root_exe) {
          Write-Host "âœ“ Found root directory copy: $root_exe"
        } else {
          Write-Host "âš  Root directory copy not found: $root_exe"
        }
        
    - name: Prepare release assets
      id: prepare_release_assets
      shell: pwsh
      run: |
        Write-Host "Preparing release files (CPU version)..."
        $build_description = "cpu"
        $performance_note = "Standard CPU version"
        
        # Create release directory
        New-Item -ItemType Directory -Force -Path "release-assets"
        
        # Copy the main executable file
        $version = "${{ steps.version.outputs.version }}"
        $release_name = "file_renamer_cli_$($version)_windows_x64_$build_description.exe"
        Copy-Item "build\Release\file_renamer_cli.exe" "release-assets\$release_name"
        
        Write-Host "Release file preparation complete ($performance_note):"
        Get-ChildItem "release-assets" | ForEach-Object {
          Write-Host "  - $($_.Name) ($([math]::Round($_.Length/1KB, 2)) KB)"
        }
        
        # Output build type information for subsequent steps
        Write-Output "build_description=$build_description" >> $env:GITHUB_OUTPUT
        Write-Output "performance_note=$performance_note" >> $env:GITHUB_OUTPUT
        
    - name: Create release notes
      shell: pwsh
      run: |
        $version = "${{ steps.version.outputs.version }}"

        # Get the latest commit information
        $commit_message = git log -1 --pretty=format:"%s"
        $commit_body = git log -1 --pretty=format:"%b"
        $commit_hash = git log -1 --pretty=format:"%h"
        
        # Create release notes
        $content = @()
        
        $content += "## ðŸ“¦ File Renamer CLI Tool $version (CPU Version)"
        
        # Add commit information
        if ($commit_message) {
          $content += "## Update Notes"
          $content += "- $commit_message"
          if ($commit_body -and $commit_body.Trim() -ne "") {
            $commit_body.Split("`n") | ForEach-Object {
              if ($_.Trim() -ne "") {
                $content += "- $($_.Trim())"
              }
            }
          }
          $content += ""
          $content += "*Commit: $commit_hash*"
          $content += ""
        }
        $content | Out-File "release-notes.md" -Encoding UTF8
        Write-Host "Release notes generated (cpu version)"

    - name: Create Release
      id: create_release
      shell: pwsh
      run: |
        $version = "${{ steps.version.outputs.version }}"
        $release_name = "File Renamer CLI Tool $version"
        
        # Check if the Release already exists
        try {
          $headers = @{
            'Authorization' = 'token ${{ secrets.GITHUB_TOKEN }}'
            'Accept' = 'application/vnd.github.v3+json'
          }
          
          Write-Host "Checking if Release exists: $version"
          $existing_release = $null
          
          try {
            $existing_release = Invoke-RestMethod -Uri "https://api.github.com/repos/${{ github.repository }}/releases/tags/$version" -Headers $headers
            Write-Host "Found existing Release: $version"
          } catch {
            if ($_.Exception.Response.StatusCode -eq 404) {
              Write-Host "Release $version does not exist, creating a new Release"
              $existing_release = $null
            } else {
              throw $_.Exception
            }
          }
          
          if ($existing_release) {
            Write-Host "Release $version already exists, reusing the existing Release"
            Write-Host "Release ID: $($existing_release.id)"
            Write-Host "Release URL: $($existing_release.html_url)"
            
            # Output existing Release information for subsequent steps
            Write-Output "upload_url=$($existing_release.upload_url)" >> $env:GITHUB_OUTPUT
            Write-Output "html_url=$($existing_release.html_url)" >> $env:GITHUB_OUTPUT
            Write-Output "id=$($existing_release.id)" >> $env:GITHUB_OUTPUT
            Write-Output "created=false" >> $env:GITHUB_OUTPUT
          } else {
            Write-Host "Creating a new Release: $version"
            
            # Read release notes
            $body = Get-Content "release-notes.md" -Raw -Encoding UTF8
            
            $release_data = @{
              tag_name = $version
              target_commitish = "main"
              name = $release_name
              body = $body
              draft = $false
              prerelease = $false
            } | ConvertTo-Json -Depth 10
            
            $new_release = Invoke-RestMethod -Uri "https://api.github.com/repos/${{ github.repository }}/releases" -Method POST -Headers $headers -Body $release_data
            
            Write-Host "New Release created"
            Write-Host "Release ID: $($new_release.id)"
            Write-Host "Release URL: $($new_release.html_url)"
            
            # Output new Release information for subsequent steps
            Write-Output "upload_url=$($new_release.upload_url)" >> $env:GITHUB_OUTPUT
            Write-Output "html_url=$($new_release.html_url)" >> $env:GITHUB_OUTPUT
            Write-Output "id=$($new_release.id)" >> $env:GITHUB_OUTPUT
            Write-Output "created=true" >> $env:GITHUB_OUTPUT
          }
        } catch {
          Write-Error "Error processing Release: $($_.Exception.Message)"
          Write-Error "Status code: $($_.Exception.Response.StatusCode)"
          Write-Error "Status description: $($_.Exception.Response.StatusDescription)"
          exit 1
        }
        
    - name: Upload Release Asset - Main Executable
      shell: pwsh
      run: |
        $version = "${{ steps.version.outputs.version }}"
        $build_description = "${{ steps.prepare_release_assets.outputs.build_description }}"
        $asset_name = "file_renamer_cli_$($version)_windows_x64_$build_description.exe"
        $asset_path = "release-assets/$asset_name"
        $upload_url = "${{ steps.create_release.outputs.upload_url }}"
        
        # Check if file exists
        if (-not (Test-Path $asset_path)) {
          Write-Error "File to upload not found: $asset_path"
          exit 1
        }
        
        try {
          $headers = @{
            'Authorization' = 'token ${{ secrets.GITHUB_TOKEN }}'
            'Content-Type' = 'application/octet-stream'
          }
          
          # Check if file with same name already exists in Release
          $release_id = "${{ steps.create_release.outputs.id }}"
          $assets_url = "https://api.github.com/repos/${{ github.repository }}/releases/$release_id/assets"
          
          Write-Host "Checking existing files..."
          try {
            $existing_assets = Invoke-RestMethod -Uri $assets_url -Headers @{
              'Authorization' = 'token ${{ secrets.GITHUB_TOKEN }}'
              'Accept' = 'application/vnd.github.v3+json'
            }
            
            $existing_asset = $existing_assets | Where-Object { $_.name -eq $asset_name }
            
            if ($existing_asset) {
              Write-Host "File $asset_name already exists in Release, deleting old version"
              $delete_url = "https://api.github.com/repos/${{ github.repository }}/releases/assets/$($existing_asset.id)"
              Invoke-RestMethod -Uri $delete_url -Method DELETE -Headers @{
                'Authorization' = 'token ${{ secrets.GITHUB_TOKEN }}'
              }
              Write-Host "Old version deleted"
            } else {
              Write-Host "File $asset_name does not exist, preparing to upload new file"
            }
          } catch {
            Write-Host "Error checking existing files, continuing with upload: $($_.Exception.Message)"
          }
          
          # Prepare upload URL
          $upload_url_clean = $upload_url -replace '\{\?name,label\}', "?name=$asset_name"
          Write-Host "Upload URL: $upload_url_clean"
          
          # Read file and upload
          $file_bytes = [System.IO.File]::ReadAllBytes((Resolve-Path $asset_path))
          Write-Host "File size: $([math]::Round($file_bytes.Length/1KB, 2)) KB"
          
          $response = Invoke-RestMethod -Uri $upload_url_clean -Method POST -Headers $headers -Body $file_bytes
          
          Write-Host "âœ“ File upload successful: $asset_name"
          Write-Host "  Download URL: $($response.browser_download_url)"
          Write-Host "  File size: $([math]::Round($response.size/1KB, 2)) KB"
          
        } catch {
          Write-Error "File upload failed: $($_.Exception.Message)"
          Write-Error "Status code: $($_.Exception.Response.StatusCode)"
          Write-Error "Status description: $($_.Exception.Response.StatusDescription)"
          
          if ($_.Exception.Response) {
            try {
              $reader = New-Object System.IO.StreamReader($_.Exception.Response.GetResponseStream())
              $responseBody = $reader.ReadToEnd()
              Write-Error "Response content: $responseBody"
            } catch {
              Write-Host "Unable to read response content"
            }
          }
          exit 1
        }

    - name: Build Summary
      shell: pwsh
      run: |
        $created = "${{ steps.create_release.outputs.created }}"
        $action = if ($created -eq "true") { "Created" } else { "Reused" }
        $performance_note = "${{ steps.prepare_release_assets.outputs.performance_note }}"
        
        Write-Host "ðŸŽ‰ Build and release completed!"
        Write-Host ""
        Write-Host "ðŸ“‹ Build Summary:"
        Write-Host "  Version: ${{ steps.version.outputs.version }}"

        Write-Host "  Build Type: CPU Standard Version"
        
        Write-Host "  Release Operation: $action"
        Write-Host "  Release URL: ${{ steps.create_release.outputs.html_url }}"
        Write-Host ""
        Write-Host "ðŸ“¦ Released Files:"
        Get-ChildItem "release-assets" | ForEach-Object {
          Write-Host "  âœ“ $($_.Name)"
        }
        Write-Host ""
        Write-Host "ðŸ”— Download Links:"
        Write-Host "  Release Page: ${{ steps.create_release.outputs.html_url }}"
        Write-Host ""
